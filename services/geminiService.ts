import { GoogleGenAI, Type, GenerateContentResponse } from "@google/genai";

interface SeoSuggestion {
    title: string;
    description: string;
}

export interface ArticleOutline {
    introduction_summary: string;
    sections: {
        section_title: string;
        section_summary: string;
    }[];
    conclusion_summary: string;
    faq_section?: {
        faq_title: string;
        questions: {
            question: string;
            answer: string;
        }[];
    };
    data_table?: {
        table_title: string;
        headers: string[];
        rows: string[][];
    };
    quote?: {
        quote_text: string;
        quote_author: string;
    };
}


export const generateSeoMetadata = async (markdownText: string, apiKey: string): Promise<SeoSuggestion> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });
    const prompt = `Based on the following markdown article, generate a concise and SEO-friendly title and meta description. The title should be under 60 characters and the description should be under 160 characters.

Markdown Article:
---
${markdownText}
---
`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        title: {
                            type: Type.STRING,
                            description: "A concise, SEO-friendly title (under 60 characters)."
                        },
                        description: {
                            type: Type.STRING,
                            description: "A compelling meta description (under 160 characters)."
                        }
                    },
                    required: ["title", "description"]
                },
            }
        });

        const jsonText = response.text.trim();
        const result = JSON.parse(jsonText);
        
        if (result && typeof result.title === 'string' && typeof result.description === 'string') {
            return result;
        } else {
            throw new Error("Invalid JSON response format from AI.");
        }
    } catch (error) {
        console.error("Error generating SEO metadata:", error);
        throw new Error("Failed to generate SEO metadata with AI. Please check your API key and console for details.");
    }
};


export const convertMarkdownToSemanticHtml = async (markdownText: string, apiKey: string): Promise<string> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });
    const prompt = `You are a world-class senior frontend engineer and SEO expert. Your sole mission is to convert the provided Markdown into a single block of perfectly semantic, accessible, and highly-optimized HTML5 code. The output is intended to be placed inside an <article> tag and MUST score 100 on Google Lighthouse audits for SEO, Accessibility, and Best Practices.

Follow these inviolable rules for the conversion:

**1. Overall Structure (MANDATORY):**
   - The output MUST begin with the \`<h1>\` element.
   - The rest of the article content MUST be structured into \`<section>\` elements. Each section should be based on an \`<h2>\` heading.
   - DO NOT generate a Table of Contents (TOC).

**2. Section and Header Structure (MANDATORY):**
   - Every \`<h2>\` heading and all of its content (paragraphs, lists, images, etc., up to the next \`<h2>\` or the end of the article) MUST be wrapped in a single, top-level \`<section class="section-part">\` tag.
   - Inside each \`<section>\`, the \`<h2>\` heading MUST be the first element and it MUST be wrapped inside a \`<header class="header-part">\` tag.
   - The \`<h2>\` element itself MUST have a URL-friendly \`id\` attribute, generated by slugifying its text content (e.g., "Hello World" becomes "hello-world"). Use only lowercase letters, numbers, and hyphens.
   - Example of the required structure:
     \`\`\`html
     <section class="section-part">
         <header class="header-part">
             <h2 id="section-title">Section Title</h2>
         </header>
         <p>Content for this section follows the header.</p>
     </section>
     \`\`\`

**3. Semantic Purity and Content Rules:**
   - Paragraphs of text, especially multi-sentence content inside list items, MUST be wrapped in \`<p>\` tags.
   - Use \`<strong>\` and \`<em>\` for emphasis. NEVER use \`<b>\` or \`<i>\`.
   - NEVER use \`<br>\` tags for spacing.

**4. Image Optimization (Core Web Vitals & SEO):**
   - Every \`<img>\` tag MUST be wrapped in a \`<figure>\` element.
   - Every \`<img>\` tag MUST have \`loading="lazy"\` and \`decoding="async"\` attributes.
   - Every \`<img>\` tag MUST have a highly descriptive \`alt\` attribute.
   - If the Markdown image includes a title (e.g., \`![alt](src "title")\`), generate a \`<figcaption>\` inside the \`<figure>\`.

**5. Link Optimization (SEO & Security):**
   - All external links (starting with \`http\` or \`https\`) MUST have \`rel="noopener noreferrer"\`.

**6. Table Accessibility:**
   - Tables MUST have a proper structure: \`<table>\`, \`<thead>\`, \`<tbody>\`, \`<tr>\`, \`<th>\`, and \`<td>\`.
   - Every \`<table>\` element MUST have the class \`table-blog\`.
   - All table header cells (\`<th>\`) MUST have a \`scope="col"\` attribute.

**7. Code Block Syntax Highlighting:**
   - Code blocks must be wrapped in \`<pre><code class="language-...">\`. The \`language-...\` class is derived from the markdown fence.

**8. Final Output Constraints:**
   - The final output MUST be only the HTML content for the article body.
   - It MUST NOT include \`<html>\`, \`<head>\`, \`<body>\`, or \`<article>\` tags.
   - DO NOT include any explanations, comments, or markdown fences.

Markdown to convert:
---
${markdownText}
---
`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
        });
        return response.text.trim();
    } catch (error) {
        console.error("Error converting Markdown to semantic HTML:", error);
        throw new Error("AI-powered conversion failed. Please check your API key and console for details.");
    }
};

export const generateText = async (prompt: string, apiKey: string): Promise<string> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
        });
        return response.text.trim();
    } catch (error) {
        console.error("Error generating text:", error);
        throw new Error("AI text generation failed. Please check your API key and console for details.");
    }
};

export const generateArticleStream = async (
    prompt: string,
    apiKey: string,
    useGoogleSearch: boolean
): Promise<AsyncGenerator<GenerateContentResponse>> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });

    const config: any = {};
    if (useGoogleSearch) {
        config.tools = [{ googleSearch: {} }];
    }

    try {
        const response = await ai.models.generateContentStream({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: config,
        });
        return response;
    } catch (error) {
        console.error("Error generating article stream:", error);
        throw new Error("AI article generation failed. Please check your API key and console for details.");
    }
};

export const generateArticleOutline = async (prompt: string, apiKey: string): Promise<ArticleOutline> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });
    
    const outlineSchema = {
      type: Type.OBJECT,
      properties: {
        introduction_summary: {
          type: Type.STRING,
          description: "A brief summary (1-2 sentences) of the introduction's main point.",
        },
        sections: {
          type: Type.ARRAY,
          description: "An array of the main sections for the article body.",
          items: {
            type: Type.OBJECT,
            properties: {
              section_title: {
                type: Type.STRING,
                description: "The heading for this section.",
              },
              section_summary: {
                type: Type.STRING,
                description: "A brief summary (1-2 sentences) of what this section will cover.",
              },
            },
            required: ['section_title', 'section_summary'],
          },
        },
        conclusion_summary: {
          type: Type.STRING,
          description: "A brief summary (1-2 sentences) of the article's conclusion.",
        },
        faq_section: {
            type: Type.OBJECT,
            description: "An optional FAQ section with 3-4 relevant questions and answers.",
            properties: {
                faq_title: { type: Type.STRING },
                questions: {
                    type: Type.ARRAY,
                    items: {
                        type: Type.OBJECT,
                        properties: {
                            question: { type: Type.STRING },
                            answer: { type: Type.STRING },
                        },
                        required: ['question', 'answer'],
                    },
                },
            },
        },
        data_table: {
            type: Type.OBJECT,
            description: "An optional data table if relevant to the topic.",
            properties: {
                table_title: { type: Type.STRING },
                headers: { type: Type.ARRAY, items: { type: Type.STRING } },
                rows: { type: Type.ARRAY, items: { type: Type.ARRAY, items: { type: Type.STRING } } },
            },
        },
        quote: {
            type: Type.OBJECT,
            description: "An optional relevant quote.",
            properties: {
                quote_text: { type: Type.STRING },
                quote_author: { type: Type.STRING },
            },
        },
      },
      required: ['introduction_summary', 'sections', 'conclusion_summary'],
    };

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: outlineSchema,
            },
        });
        const jsonText = response.text.trim();
        const result = JSON.parse(jsonText);
        // Basic validation to ensure the result matches the expected structure
        if (result && result.sections && Array.isArray(result.sections)) {
            return result as ArticleOutline;
        } else {
            throw new Error("Invalid JSON outline structure from AI.");
        }
    } catch (error) {
        console.error("Error generating article outline:", error);
        throw new Error("Failed to generate article outline with AI. Please check your API key and console for details.");
    }
};

export const generateImage = async (prompt: string, apiKey: string): Promise<string> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });

    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: `A high-quality, photorealistic featured image for a blog article titled: "${prompt}". Minimalist, clean aesthetic. Aspect ratio 16:9.`,
            config: {
              numberOfImages: 1,
              outputMimeType: 'image/jpeg',
              aspectRatio: '16:9',
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            return response.generatedImages[0].image.imageBytes;
        } else {
            throw new Error("No image was generated by the API.");
        }
    } catch (error) {
        console.error("Error generating image:", error);
        throw new Error("AI image generation failed. Please check your API key and console for details.");
    }
};


export const validateApiKey = async (apiKey: string): Promise<boolean> => {
    if (!apiKey) {
        return false;
    }
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

    try {
        const httpResponse = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contents: [{ parts: [{ text: "hi" }] }] }),
        });

        if (httpResponse.ok) {
            const data = await httpResponse.json();
            if (data.candidates && data.candidates.length > 0) {
                return true;
            }
        }
        
        const errorData = await httpResponse.json().catch(() => ({ error: 'Could not parse error response.' }));
        console.error("API Key validation failed. Status:", httpResponse.status, "Response:", errorData);
        return false;

    } catch (error) {
        console.error("API Key validation failed with a network error:", error);
        return false;
    }
};