import { GoogleGenAI, Type } from "@google/genai";

interface SeoSuggestion {
    title: string;
    description: string;
}

export const generateSeoMetadata = async (markdownText: string, apiKey: string): Promise<SeoSuggestion> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });
    const prompt = `Based on the following markdown article, generate a concise and SEO-friendly title and meta description. The title should be under 60 characters and the description should be under 160 characters.

Markdown Article:
---
${markdownText}
---
`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        title: {
                            type: Type.STRING,
                            description: "A concise, SEO-friendly title (under 60 characters)."
                        },
                        description: {
                            type: Type.STRING,
                            description: "A compelling meta description (under 160 characters)."
                        }
                    },
                    required: ["title", "description"]
                },
            }
        });

        const jsonText = response.text.trim();
        const result = JSON.parse(jsonText);
        
        if (result && typeof result.title === 'string' && typeof result.description === 'string') {
            return result;
        } else {
            throw new Error("Invalid JSON response format from AI.");
        }
    } catch (error) {
        console.error("Error generating SEO metadata:", error);
        throw new Error("Failed to generate SEO metadata with AI. Please check your API key and console for details.");
    }
};


export const convertMarkdownToSemanticHtml = async (markdownText: string, apiKey: string): Promise<string> => {
    if (!apiKey) {
        throw new Error("Google Gemini API key not provided.");
    }
    const ai = new GoogleGenAI({ apiKey });
    const prompt = `You are a world-class senior frontend engineer and SEO expert. Your sole mission is to convert the provided Markdown into a single block of perfectly semantic, accessible, and highly-optimized HTML5 code. The output is intended to be placed inside an <article> tag and MUST score 100 on Google Lighthouse audits for SEO, Accessibility, and Best Practices.

Follow these inviolable rules for the conversion:

**1. Overall Structure (MANDATORY):**
   - The output MUST begin with the \`<h1>\` element.
   - The rest of the article content MUST be structured into \`<section>\` elements. Each section should be based on an \`<h2>\` heading.
   - DO NOT generate a Table of Contents (TOC).

**2. Section and Header Structure (MANDATORY):**
   - Every \`<h2>\` heading and all of its content (paragraphs, lists, images, etc., up to the next \`<h2>\` or the end of the article) MUST be wrapped in a single, top-level \`<section class="section-part">\` tag.
   - Inside each \`<section>\`, the \`<h2>\` heading MUST be the first element and it MUST be wrapped inside a \`<header class="header-part">\` tag.
   - The \`<h2>\` element itself MUST have a URL-friendly \`id\` attribute, generated by slugifying its text content (e.g., "Hello World" becomes "hello-world"). Use only lowercase letters, numbers, and hyphens.
   - Example of the required structure:
     \`\`\`html
     <section class="section-part">
         <header class="header-part">
             <h2 id="section-title">Section Title</h2>
         </header>
         <p>Content for this section follows the header.</p>
     </section>
     \`\`\`

**3. Semantic Purity and Content Rules:**
   - Paragraphs of text, especially multi-sentence content inside list items, MUST be wrapped in \`<p>\` tags.
   - Use \`<strong>\` and \`<em>\` for emphasis. NEVER use \`<b>\` or \`<i>\`.
   - NEVER use \`<br>\` tags for spacing.

**4. Image Optimization (Core Web Vitals & SEO):**
   - Every \`<img>\` tag MUST be wrapped in a \`<figure>\` element.
   - Every \`<img>\` tag MUST have \`loading="lazy"\` and \`decoding="async"\` attributes.
   - Every \`<img>\` tag MUST have a highly descriptive \`alt\` attribute.
   - If the Markdown image includes a title (e.g., \`![alt](src "title")\`), generate a \`<figcaption>\` inside the \`<figure>\`.

**5. Link Optimization (SEO & Security):**
   - All external links (starting with \`http\` or \`https\`) MUST have \`rel="noopener noreferrer"\`.

**6. Table Accessibility:**
   - Tables MUST have a proper structure: \`<table>\`, \`<thead>\`, \`<tbody>\`, \`<tr>\`, \`<th>\`, and \`<td>\`.
   - Every \`<table>\` element MUST have the class \`table-blog\`.
   - All table header cells (\`<th>\`) MUST have a \`scope="col"\` attribute.

**7. Code Block Syntax Highlighting:**
   - Code blocks must be wrapped in \`<pre><code class="language-...">\`. The \`language-...\` class is derived from the markdown fence.

**8. Final Output Constraints:**
   - The final output MUST be only the HTML content for the article body.
   - It MUST NOT include \`<html>\`, \`<head>\`, \`<body>\`, or \`<article>\` tags.
   - DO NOT include any explanations, comments, or markdown fences.

Markdown to convert:
---
${markdownText}
---
`;

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
        });
        return response.text.trim();
    } catch (error) {
        console.error("Error converting Markdown to semantic HTML:", error);
        throw new Error("AI-powered conversion failed. Please check your API key and console for details.");
    }
};

export const validateApiKey = async (apiKey: string): Promise<boolean> => {
    if (!apiKey) {
        return false;
    }

    // Use a direct fetch call to bypass any SDK issues with error handling for invalid keys.
    // This provides a reliable way to check the key's validity by inspecting the HTTP response status.
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

    try {
        const httpResponse = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                // A minimal, low-cost request body for validation.
                contents: [{ parts: [{ text: "hi" }] }],
            }),
        });

        // The fetch API does not throw an error on 4xx/5xx HTTP statuses.
        // We must check the `ok` property of the response, which is true for statuses 200-299.
        // An invalid API key will result in a 400 Bad Request, so `httpResponse.ok` will be false.
        if (httpResponse.ok) {
            // As an extra check, ensure the response body is valid.
            const data = await httpResponse.json();
            if (data.candidates && data.candidates.length > 0) {
                return true;
            }
        }
        
        // If the response was not 'ok' or the body was malformed, the key is invalid.
        const errorData = await httpResponse.json().catch(() => ({ error: 'Could not parse error response.' }));
        console.error("API Key validation failed. Status:", httpResponse.status, "Response:", errorData);
        return false;

    } catch (error) {
        // This catches network-level errors like CORS, DNS issues, or no internet connection.
        console.error("API Key validation failed with a network error:", error);
        return false;
    }
};